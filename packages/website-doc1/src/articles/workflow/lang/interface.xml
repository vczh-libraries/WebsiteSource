<article index="true">
    <topic>
        <title>Interfaces</title>
        <p>
            Interfaces can be defined in <b>modules</b>, <b>namespaces</b>, <b>classes</b> and <b>interfaces</b>.
        </p>
        <p>
            An interface shapes an object by defining how methods, properties and events look like.
        </p>
        <p>
            An interface usually begins with:
            <ul>
                <li>
                    <b>interface IMyInterface</b>:
                    it means the new interface expression creates an object that implements this interface
                    and returns a shared pointer holding this object.
                    Such expression should look like: <b>new IMyInterface^ { ... }</b>.
                </li>
                <li>
                    <b>interface IMyInterface*</b>:
                    it means the new interface expression creates an object that implements this interface
                    and returns a raw pointer holding this object.
                    Such expression should look like: <b>new IMyInterface* { ... }</b>.
                </li>
            </ul>
        </p>
        <p>
            Methods, properties and events are allowed to be in both interface declaration and new interface expressions.
        </p>
        <p>
            Variables are allowed to be in new interface expressions.
            Variables are only accessible to methods in this new interface expression.
        </p>
        <p>
            All methods, including that are generated by properties,
            must be overrided in the new interface expression,
            using <b>override</b> keyword before functions.
        </p>
        <p>
            <program><code><![CDATA[
                module sampleModule;

                interface ICounter
                {
                    func Increase(): int;
                }

                func main(): string
                {
                    var counter = new ICounter^
                    {
                        var x: int = 0;

                        override func Increase(): int
                        {
                            x = x + 1;
                            return x;
                        }
                    };

                    var r = "";
                    for (i in range [0, 10))
                    {
                        r = r & $"$(counter.Increase()); ";
                    }
                    return r;
                }
            ]]></code></program>
        </p>
        <p>
            In this example,
            we define an interface <b>ICounter</b>.
            Note that we didn't use <b>interface ICounter*</b> here,
            it means that <b>new ICounter^ { ... }</b> is legal, but <b>new ICounter* { ... }</b> is not.
            So the type of <b>counter</b> is <b>ICounter^</b>.
        </p>
        <p>
            This interface has a method called <b>Increase</b>,
            which makes <b>counter.Increase()</b> a valid expression.
        </p>
        <p>
            All variables defined at parent scopes of this new interface expression are captured by value.
            But since <b>counter</b> doesn't have an explicit type,
            so visiting <b>counter</b> in this new interface expression results in an error,
            because the type is not recognized yet when processing members of this new interface expression.
        </p>
        <p>
            <b>IMPORTANT</b>:
            even if <b>counter</b> is hidden from the method,
            but when the method is resolving the name <b>counter</b>,
            all symbols called <b>counter</b> will be examined before picking the right one,
            so it still generates an error.
        </p>
        <p>
            Now we call <b>counter.Increase()</b> 10 times,
            which generates numbers from 1 to 10.
            Function <b>main</b> returns <b>"1; 2; 3; 4; 5; 6; 7; 8; 9; 10; "</b>.
        </p>
    </topic>
</article>