<article index="true">
    <topic>
        <title>Design Your Own Coroutine</title>
        <p>
            A coroutine provider is a class with methods that following a naming convention.
        </p>
        <p>
            A coroutine provider could be written in either C++ with reflection, or just Workflow.
        </p>
        <topic>
            <title>Naming your coroutine</title>
            <p>
                If you want a coroutine to be written in this way:
                <program><code><![CDATA[
                    func MyCoroutine(): void
                    $Foo {
                        /* ... */
                    }
                ]]></code></program>
                you need to define the coroutine provider like this:
                <program><code><![CDATA[
                    using system::*;

                    class FooCoroutine
                    {
                        class InternalState
                        {
                            /* ... */
                        }

                        static CreateAndRun(creator: func(InternalState*): (Coroutine^)): void
                        {
                            /* ... */
                        }
                    }
                ]]></code></program>
            </p>
            <p>
                If you want a coroutine to be written in this way:
                <program><code><![CDATA[
                    func MyCoroutine(): Foo^
                    ${
                        /* ... */
                    }
                ]]></code></program>
                or
                <program><code><![CDATA[
                    $interface StringFoo : Foo<string>;
                    func MyCoroutine(): StringFoo^
                    ${
                        /* ... */
                    }
                ]]></code></program>
                you need to define the coroutine provider like this:
                <program><code><![CDATA[
                    using system::*;

                    interface Foo
                    {
                        /* ... */
                    }

                    class FooCoroutine
                    {
                        class InternalState
                        {
                            /* ... */
                        }

                        static Create(creator: func(InternalState*): (Coroutine^)): Foo^
                        {
                            /* ... */
                        }
                    }
                ]]></code></program>
            </p>
            <p>
                <ul>
                    <li>
                        <b>FooCoroutine::InternalState</b> could be a class or an interface.
                    </li>
                    <li>
                        <b>Create</b> and <b>CreateAndRun</b> could both appear.
                        This makes coroutine functions being able to return both <b>void</b> and <b>Foo^</b>.
                    </li>
                    <li>
                        The return type of <b>Create</b> must be compatible with the return type of coroutine functions:
                        <ul>
                            <li>If <b>Create</b> returns <b>Foo^</b>, then coroutine functions could return <b>Foo^</b> or any of its base type.</li>
                            <li>If <b>Create</b> returns <b>Foo^</b>, then coroutine functions could return a generic version of <b>Foo^</b>.</li>
                        </ul>
                    </li>
                    <li>
                        The only argument of <b>Create</b> or <b>CreateAndRun</b> should be a function:
                        <ul>
                            <li>It takes a raw pointer of an object for storing internal states.</li>
                            <li>It must return <b>Coroutine^</b>.</li>
                        </ul>
                    </li>
                </ul>
            </p>
            <p>
                When a coroutine function is called,
                either <b>Create</b> or <b>CreateAndRun</b> will be called.
                You are responsible to create the object for storing internal states,
                and then a <b>Coroutine^</b> will be given to you.
            </p>
            <p>
                Nothing in the coroutine function is executed before the first call to <b>Coroutine::Resume</b>.
            </p>
            <p>
                Whenever a coroutine operation is called,
                the coroutine pauses,
                and another call to <b>Coroutine::Resume</b> is required to continue the coroutine function.
            </p>
        </topic>
        <topic>
            <title>Define coroutine operations</title>
            <p>
                If you want to support
                <program><code><![CDATA[
                    $Do1;
                    $Do2 something;
                    $Do3 something, otherthings;
                ]]></code></program>
                you are required to add the following methods to your coroutine provider:
                <program><code><![CDATA[
                    static Do1AndPause(internalState: InternalState*): void { /* ... */ }
                    static Do2AndPause(internalState: InternalState*, something: Something): void { /* ... */ }
                    static Do3AndPause(internalState: InternalState*, something: Something, otherthings: Otherthings): void { /* ... */ }
                ]]></code></program>
            </p>
            <p>
                If you want to support both
                <program><code><![CDATA[
                    $Do1;
                    $Do2 something;
                    $Do3 something, otherthings;
                ]]></code></program>
                and
                <program><code><![CDATA[
                    var x = $Do1;
                    var y = $Do2 something;
                    var z = $Do3 something, otherthings;
                ]]></code></program>
                you are required to add the following methods to your coroutine provider:
                <program><code><![CDATA[
                    static Do1AndRead(internalState: InternalState*): void { /* ... */ }
                    static Do2AndRead(internalState: InternalState*, something: Something): void { /* ... */ }
                    static Do3AndRead(internalState: InternalState*, something: Something, otherthings: Otherthings): void { /* ... */ }
                ]]></code></program>
            </p>
            <p>
                Overloading is allowed.
            </p>
            <p>
                When a coroutine operation is called,
                one of these methods will be called,
                and the created <b>Coroutine^</b> will pause right after that.
            </p>
            <p>
                All methods for coroutine operations must return <b>void</b>.
                After the coroutine is resumed,
                the return value from the coroutine operation comes from the second argument in <b>Coroutine::Resume</b>.
            </p>
            <p>
                This argument is a <b>CoroutineResult^</b>.
                <ul>
                    <li>If the coroutine operation succeeds, the return value is stored in the <b>Result</b> property.</li>
                    <li>If the coroutine operation succeeds, the exception is stored in the <b>Failure</b> property.</li>
                    <li>
                        If <b>Failure</b> is not null,
                        <b>Result</b> will be ignored.
                        and an exception is thrown.
                        If there is no <b>try-catch</b> in this coroutine function,
                        the coroutine stops immediately with this exception.
                    </li>
                </ul>
            </p>
        </topic>
        <topic>
            <title>Define return statement</title>
        </topic>
        <topic>
            <title>Define $ expression</title>
        </topic>
        <topic>
            <title>Example</title>
        </topic>
    </topic>
</article>