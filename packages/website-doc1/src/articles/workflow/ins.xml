<article index="true">
    <topic>
        <title>Runtime Instructions</title>
        <p>
            This is for reference only.
            You are not expected to generate instructions by yourself,
            but it could be useful when programming against the Workflow script debugger interface.
        </p>
        <p>
            All instructions are defined in <b>vl::workflow::runtime::WfInsCode</b>.
        </p>
        <p>
            An instruction could have two types of arguments:
            <ul>
                <li><b>Embedded arguments</b>: They are generated at compile time and are saved in fields of <b>vl::workflow::runtime::WfInstruction</b>.</li>
                <li><b>Stack arguments</b>: They are stored in the stack at runtime, most of them will be consumed and removed from the stack after executing the instruction.</li>
            </ul>
            Argument schema of each instructions are defined by static methods of <b>vl::workflow::runtime::WfInstruction</b>.
        </p>
        <p>
            When an instruction is named after, for example, <b>ConvertToType(flag, type)</b>,
            it means the name of the instruction is <b>WfInsCode::ConvertToType</b>,
            and embedded arguments are stored in field <b>flagParameter</b> and <b>typeParameter</b>.
        </p>
        <topic>
            <title>Stack Operations</title>
            <topic>
                <title>Nop</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    This instruction does nothing.
                </p>
            </topic>
            <topic>
                <title>LoadValue(value)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value
                    ]]></code></program>
                </p>
                <p>
                    Push a value to the stack.
                </p>
            </topic>
            <topic>
                <title>LoadFunction(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        index
                    ]]></code></program>
                </p>
                <p>
                    Push the function index to the stack.
                    This instruction load functions for creating closures.
                    To push a function value to the stack,
                    use <b>CreateClosure</b> instead.
                </p>
            </topic>
            <topic>
                <title>LoadException</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value of the exception
                    ]]></code></program>
                </p>
                <p>
                    Push the exception object of the current thread context to the stack.
                </p>
            </topic>
            <topic>
                <title>LoadLocalVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (int) value of the variable
                    ]]></code></program>
                </p>
                <p>
                    Push the value of the local variable of the specified index to the stack.
                    Local variables are stored in the current stack frame.
                </p>
            </topic>
            <topic>
                <title>LoadCapturedVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value of the variable
                    ]]></code></program>
                </p>
                <p>
                    Push the value of the captured variable of the specified index to the stack.
                    Captured variables are stored in the closure context that is assigned to the current stack frame.
                </p>
            </topic>
            <topic>
                <title>LoadGlobalVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value of the variable
                    ]]></code></program>
                </p>
                <p>
                    Push the value of the global variable of the specified index to the stack.
                </p>
            </topic>
            <topic>
                <title>LoadMethodInfo(method)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (IMethodInfo*)
                    ]]></code></program>
                </p>
                <p>
                    Push the <b>IMethodInfo*</b> object to the stack.
                </p>
            </topic>
            <topic>
                <title>LoadMethodClosure(method)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        closure of the IMethodInfo* object
                    ]]></code></program>
                </p>
                <p>
                    Push the closure of the <b>IMethodInfo*</b> object to the stack.
                    It is created by calling <b>IMethodInfo::CreateFunctionProxy</b>,
                    this function returns a function object that can be invoked.
                </p>
            </topic>
            <topic>
                <title>LoadClosureContext</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (Ptr<WfRuntimeVariableContext>)
                    ]]></code></program>
                </p>
                <p>
                    Push the closure context of the current stack frame to the stack.
                    Local variables are stored in the current stack frame.
                </p>
            </topic>
            <topic>
                <title>StoreLocalVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack to update a specified local variable.
                </p>
            </topic>
            <topic>
                <title>StoreCapturedVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack to update a specified captured variable.
                    Captured variables are stored in the closure context that is assigned to the current stack frame.
                </p>
            </topic>
            <topic>
                <title>StoreGlobalVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack to update a specified global variable.
                </p>
            </topic>
            <topic>
                <title>Duplicate</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value
                        value
                    ]]></code></program>
                </p>
                <p>
                    Duplicate the top value in the stack.
                </p>
            </topic>
            <topic>
                <title>Pop</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack.
                </p>
            </topic>
        </topic>
        <topic>
            <title>Jumping Operations</title>
            <topic>
                <title>Return</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> stack frame 1 (top)
                        value
                        ... others
                        --> stack frame 2
                        ... others
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> stack frame 2 (top)
                        value
                        ... others
                    ]]></code></program>
                </p>
                <p>
                    Pop a value as a function return value,
                    pop the current stack frame so that all remaining values of this stack frame is removed,
                    push the return value to the next stack frame,
                    and the function ends, jumping to the next instruction from one that calling into the current function.
                    If there is not stack frame after running this instruction,
                    the return value will be the only value in the stack,
                    and the script ends.
                </p>
            </topic>
            <topic>
                <title>Jump(index)</title>
                <p>
                    Jump to the specified instruction.
                </p>
            </topic>
            <topic>
                <title>JumpIf(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack.
                    If it is <b>true</b>, jump to the specified instruction.
                    If it is <b>false</b>, continue to execute the next instruction.
                    If it is not a boolean value, exception occurs.
                </p>
            </topic>
            <topic>
                <title>Invoke(index, count)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> stack frame 2 (top)
                        arg-n
                        ...
                        arg-1
                        ... others
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> stack frame 1 (top)
                        ... local variables
                        arg-n
                        ...
                        arg-1
                        --> stack frame 2 (top)
                        ... others
                    ]]></code></program>
                </p>
                <p>
                    Jump to the specified function, taking a specified number of stack values as arguments.
                    Arguments are transferred to the new stack frame,
                    so after the function ends,
                    they are all gone.
                </p>
            </topic>
            <topic>
                <title>InvokeWithContext(index, count)</title>
                <p>
                    Works like <b>Invoke(index, count)</b>,
                    but the target function shares captured values of the current function.
                    This happens when methods of the same interface implementation are calling each other,
                    because all of these methods share the same captured values.
                </p>
            </topic>
            <topic>
                <title>InstallTry(index)</title>
                <p>
                    Push a new trap frame with the entry instruction to the <b>catch</b> handler.
                    <b>UninstallTry(count)</b> must be called pairing with <b>InstallTry(index)</b>.
                </p>
            </topic>
            <topic>
                <title>UninstallTry(count)</title>
                <p>
                    Pop a new trap frame.
                    Keep the specified number of stack values right after this trap frame.
                    This happens when no exception occurs while evaluating the left operand of the <b>??</b> operator,
                    the value of the left operand becomes the value of the whole expression,
                    which should be kept in the stack.
                </p>
            </topic>
            <topic>
                <title>RaiseException</title>
                <p>
                    Raise an exception.
                </p>
                <p>
                    When an exception occurs,
                    all stack frames and stack values that are pushed after the top trap frame will be removed,
                    and jump to the specified instruction of the top trap frame.
                    If there is no trap frame,
                    the script ends with this exception.
                </p>
            </topic>
        </topic>
        <topic>
            <title>Object Creating Operations</title>
            <topic>
                <title>CreateArray(count)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        item-1
                        ...
                        item-n
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (Ptr<IValueList>) value of created array
                    ]]></code></program>
                </p>
                <p>
                    Pop the specified number of values from the stack,
                    push the created array containing these values in popping order.
                </p>
            </topic>
            <topic>
                <title>CreateObservableList(count)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        item-1
                        ...
                        item-n
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (Ptr<IValueObservableList>) value of created observable list
                    ]]></code></program>
                </p>
                <p>
                    Pop the specified number of values from the stack,
                    push the created observable list containing these values in popping order.
                </p>
            </topic>
            <topic>
                <title>CreateMap(count)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value-1
                        key-1
                        ...
                        value-n
                        key-n
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (Ptr<IValueDictionary>) value of created map
                    ]]></code></program>
                </p>
                <p>
                    Pop the specified number of value-key-pair from the stack,
                    push the created observable map.
                    A pair is two values on the stack instead of being a pair object.
                    The order of keys in the map depends on value of keys.
                </p>
            </topic>
            <topic>
                <title>CreateClosureContext(count)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        item-n
                        ...
                        item-1
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (Ptr<WfRuntimeVariableContext>) value of created closure context
                    ]]></code></program>
                </p>
                <p>
                    Pop the specified number of values from the stack,
                    push the created closure context containing these values in reverse popping order.
                    If there is no value to be stored, the created context will be <b>null</b>.
                </p>
            </topic>
            <topic>
                <title>CreateClosure</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        (int) function
                        (Ptr<WfRuntimeVariableContext>) closure context
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (Ptr<IValueFunctionProxy>) value of created closure
                    ]]></code></program>
                </p>
                <p>
                    Pop the index of global function and a closure context,
                    push the created closure to the stack.
                </p>
            </topic>
            <topic>
                <title>CreateInterface(method, count)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        (int) function-1
                        (IMethodInfo*) method-1
                        ...
                        function-n
                        method-n
                        (Ptr<WfRuntimeVariableContext>) closure context
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value of created interface
                    ]]></code></program>
                </p>
                <p>
                    Pop the specified number of function-method-pair from the stack.
                    Push the created interface to the stack.
                    A pair is two values on the stack instead of being a pair object,
                    declaring that which method is implemented by which global function.
                </p>
                <p>
                    The <b>methodParamter</b> of the instruction is the constructor of the interface.
                    Such interface must be registered using one of the <b>BEGIN_INTERFACE_PROXY_*</b> macro.
                    Please check out <a href="/vlppreflection/ref/VL__REFLECTION__DESCRIPTION.html">class Description</a> for more details.
                </p>
            </topic>
            <topic>
                <title>CreateRange</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value of ending
                        value of beginning
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (Ptr<IValueEnumerable>) value of created range
                    ]]></code></program>
                </p>
                <p>
                    Pop the value of ending and beginning in order,
                    push the created range,
                    which is a enumerable collection,
                    including the value of beginning but excluding the value of ending.
                    Each value is one greater than the previous one in this collection.
                </p>
            </topic>
            <topic>
                <title>CreateStruct(flag, type)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value of created struct
                    ]]></code></program>
                </p>
                <p>
                    Create a struct of the specified type and push to the stack.
                    All fields are filled with default values according to their types.
                </p>
            </topic>
            <topic>
                <title>DeleteRawPtr</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value to delete
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack and delete it.
                    If the value is not a raw pointer,
                    then it is just popped but not deleted.
                    Otherwise, <a href="/vlppreflection/ref/VL__REFLECTION__DESCRIPTION__VALUE__DELETERAWPTR@BOOL().html">Value::DeleteRawPtr</a> is called.
                </p>
            </topic>
        </topic>
        <topic>
            <title>Type Operations</title>
            <topic>
                <title>ConvertToType(flag, type)</title>
            </topic>
            <topic>
                <title>TryConvertToType(flag, type)</title>
            </topic>
            <topic>
                <title>TestType(flag, type)</title>
            </topic>
            <topic>
                <title>GetType</title>
            </topic>
        </topic>
        <topic>
            <title>Reflection Operations</title>
            <topic>
                <title>GetProperty(property)</title>
            </topic>
            <topic>
                <title>SetProperty(property)</title>
            </topic>
            <topic>
                <title>UpdateProperty(property)</title>
            </topic>
            <topic>
                <title>InvokeProxy(count)</title>
            </topic>
            <topic>
                <title>InvokeMethod(method, count)</title>
            </topic>
            <topic>
                <title>InvokeEvent(event, count)</title>
            </topic>
            <topic>
                <title>InvokeBaseCtor(method, count)</title>
            </topic>
            <topic>
                <title>AttachEvent(event)</title>
            </topic>
            <topic>
                <title>DetachEvent(event)</title>
            </topic>
        </topic>
        <topic>
            <title>Testing Operations</title>
            <topic>
                <title>TestElementInSet</title>
            </topic>
            <topic>
                <title>CompareLiteral(type)</title>
            </topic>
            <topic>
                <title>CompareReference</title>
            </topic>
            <topic>
                <title>CompareValue</title>
            </topic>
            <topic>
                <title>OpLT, OpGT, OpLE, OpGE, OpEQ, OpNE</title>
            </topic>
        </topic>
        <topic>
            <title>Unary Operations</title>
            <topic>
                <title>OpNot(type)</title>
            </topic>
            <topic>
                <title>OpPositive(type)</title>
            </topic>
            <topic>
                <title>OpNegative(type)</title>
            </topic>
        </topic>
        <topic>
            <title>Binary Operations</title>
            <topic>
                <title>OpConcat</title>
            </topic>
            <topic>
                <title>OpExp(type)</title>
            </topic>
            <topic>
                <title>OpAdd(type)</title>
            </topic>
            <topic>
                <title>OpSub(type)</title>
            </topic>
            <topic>
                <title>OpMul(type)</title>
            </topic>
            <topic>
                <title>OpDiv(type)</title>
            </topic>
            <topic>
                <title>OpShl(type)</title>
            </topic>
            <topic>
                <title>OpShr(type)</title>
            </topic>
            <topic>
                <title>OpXor(type)</title>
            </topic>
            <topic>
                <title>OpAnd(type)</title>
            </topic>
            <topic>
                <title>OpOr(type)</title>
            </topic>
        </topic>
    </topic>
</article>