<article index="true">
    <topic>
        <title>Runtime Instructions</title>
        <p>
            This is for reference only.
            You are not expected to generate instructions by yourself,
            but it could be useful when programming against the Workflow script debugger interface.
        </p>
        <p>
            All instructions are defined in <b>vl::workflow::runtime::WfInsCode</b>.
        </p>
        <p>
            An instruction could have two types of arguments:
            <ul>
                <li><b>Embedded arguments</b>: They are generated at compile time and are saved in fields of <b>vl::workflow::runtime::WfInstruction</b>.</li>
                <li><b>Stack arguments</b>: They are stored in the stack at runtime, most of them will be consumed and removed from the stack after executing the instruction.</li>
            </ul>
            Argument schema of each instructions are defined by static methods of <b>vl::workflow::runtime::WfInstruction</b>.
        </p>
        <p>
            When an instruction is named after, for example, <b>ConvertToType(flag, type)</b>,
            it means the name of the instruction is <b>WfInsCode::ConvertToType</b>,
            and embedded arguments are stored in field <b>flagParameter</b> and <b>typeParameter</b>.
        </p>
        <topic>
            <title>Stack Operations</title>
            <topic>
                <title>Nop</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    This instruction does nothing.
                </p>
            </topic>
            <topic>
                <title>LoadValue(value)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Push a value to the stack.
                </p>
            </topic>
            <topic>
                <title>LoadFunction(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        index
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Push the function index to the stack.
                    This instruction load functions for creating closures.
                    To push a function value to the stack,
                    use <b>CreateClosure</b> instead.
                </p>
            </topic>
            <topic>
                <title>LoadException</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value of the exception
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Push the exception object of the current thread context to the stack.
                </p>
            </topic>
            <topic>
                <title>LoadLocalVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (int) value of the variable
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Push the value of the local variable of the specified index to the stack.
                    Local variables are stored in the current stack frame.
                </p>
            </topic>
            <topic>
                <title>LoadCapturedVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value of the variable
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Push the value of the captured variable of the specified index to the stack.
                    Captured variables are stored in the closure context that is assigned to the current stack frame.
                </p>
            </topic>
            <topic>
                <title>LoadGlobalVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value of the variable
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Push the value of the global variable of the specified index to the stack.
                </p>
            </topic>
            <topic>
                <title>LoadMethodInfo(method)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (IMethodInfo*)
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Push the <b>IMethodInfo*</b> object to the stack.
                </p>
            </topic>
            <topic>
                <title>LoadMethodClosure(method)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        closure of the IMethodInfo* object
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Push the closure of the <b>IMethodInfo*</b> object to the stack.
                    It is created by calling <b>IMethodInfo::CreateFunctionProxy</b>,
                    this function returns a function object that can be invoked.
                </p>
            </topic>
            <topic>
                <title>LoadClosureContext</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        (Ptr<WfRuntimeVariableContext>)
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Push the closure context of the current stack frame to the stack.
                    Local variables are stored in the current stack frame.
                </p>
            </topic>
            <topic>
                <title>StoreLocalVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack to update a specified local variable.
                </p>
            </topic>
            <topic>
                <title>StoreCapturedVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack to update a specified captured variable.
                    Captured variables are stored in the closure context that is assigned to the current stack frame.
                </p>
            </topic>
            <topic>
                <title>StoreGlobalVar(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack to update a specified global variable.
                </p>
            </topic>
            <topic>
                <title>Duplicate</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        value
                        value
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Duplicate the top value in the stack.
                </p>
            </topic>
            <topic>
                <title>Pop</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack.
                </p>
            </topic>
        </topic>
        <topic>
            <title>Jumping Operations</title>
            <topic>
                <title>Return</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> stack frame 1 (top)
                        value
                        ... others
                        --> stack frame 2
                        ... others
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> stack frame 2 (top)
                        value
                        ... others
                    ]]></code></program>
                </p>
                <p>
                    Pop a value as a function return value,
                    pop the current stack frame so that all remaining values of this stack frame is removed,
                    push the return value to the next stack frame,
                    and the function ends, jumping to the next instruction from one that calling into the current function.
                    If there is not stack frame after running this instruction,
                    the return value will be the only value in the stack,
                    and the script ends.
                </p>
            </topic>
            <topic>
                <title>Jump(index)</title>
                <p>
                    Jump to the specified instruction.
                </p>
            </topic>
            <topic>
                <title>JumpIf(index)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> top
                        value
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> top
                        --> bottom
                    ]]></code></program>
                </p>
                <p>
                    Pop a value from the stack.
                    If it is <b>true</b>, jump to the specified instruction.
                    If it is <b>false</b>, continue to execute the next instruction.
                    If it is not a boolean value, exception occurs.
                </p>
            </topic>
            <topic>
                <title>Invoke(index, count)</title>
                <p>
                    Stack pattern before:
                    <program><code><![CDATA[
                        --> stack frame 2 (top)
                        arg-n
                        ...
                        arg-1
                        ... others
                    ]]></code></program>
                </p>
                <p>
                    Stack pattern after:
                    <program><code><![CDATA[
                        --> stack frame 1 (top)
                        ... local variables
                        arg-n
                        ...
                        arg-1
                        --> stack frame 2 (top)
                        ... others
                    ]]></code></program>
                </p>
                <p>
                    Jump to the specified function, taking a specified number of stack values as arguments.
                    Arguments are transferred to the new stack frame,
                    so after the function ends,
                    they are all gone.
                </p>
            </topic>
            <topic>
                <title>InvokeWithContext(index, count)</title>
                <p>
                    Works like <b>Invoke(index, count)</b>,
                    but the target function shares captured values of the current function.
                    This happens when methods of the same interface implementation are calling each other,
                    because all of these methods share the same captured values.
                </p>
            </topic>
            <topic>
                <title>InstallTry(index)</title>
                <p>
                    Push a new trap frame with the entry instruction to the <b>catch</b> handler.
                    <b>UninstallTry(count)</b> must be called pairing with <b>InstallTry(index)</b>.
                </p>
            </topic>
            <topic>
                <title>UninstallTry(count)</title>
                <p>
                    Pop a new trap frame.
                    Keep the specified number of stack values right after this trap frame.
                    This happens when no exception occurs while evaluating the left operand of the <b>??</b> operator,
                    the value of the left operand becomes the value of the whole expression,
                    which should be kept in the stack.
                </p>
            </topic>
            <topic>
                <title>RaiseException</title>
                <p>
                    Raise an exception.
                </p>
                <p>
                    When an exception occurs,
                    all stack frames and stack values that are pushed after the top trap frame will be removed,
                    and jump to the specified instruction of the top trap frame.
                    If there is no trap frame,
                    the script ends with this exception.
                </p>
            </topic>
        </topic>
        <topic>
            <title>Object Creating Operations</title>
            <topic>
                <title>CreateArray(count)</title>
            </topic>
            <topic>
                <title>CreateObservableList(count)</title>
            </topic>
            <topic>
                <title>CreateMap(count)</title>
            </topic>
            <topic>
                <title>CreateClosureContext(count)</title>
            </topic>
            <topic>
                <title>CreateClosure</title>
            </topic>
            <topic>
                <title>CreateInterface(method, count)</title>
            </topic>
            <topic>
                <title>CreateStruct(flag, type)</title>
            </topic>
            <topic>
                <title>DeleteRawPtr</title>
            </topic>
        </topic>
        <topic>
            <title>Type Operations</title>
            <topic>
                <title>ConvertToType(flag, type)</title>
            </topic>
            <topic>
                <title>TryConvertToType(flag, type)</title>
            </topic>
            <topic>
                <title>TestType(flag, type)</title>
            </topic>
            <topic>
                <title>GetType</title>
            </topic>
        </topic>
        <topic>
            <title>Reflection Operations</title>
            <topic>
                <title>GetProperty(property)</title>
            </topic>
            <topic>
                <title>SetProperty(property)</title>
            </topic>
            <topic>
                <title>UpdateProperty(property)</title>
            </topic>
            <topic>
                <title>InvokeProxy(count)</title>
            </topic>
            <topic>
                <title>InvokeMethod(method, count)</title>
            </topic>
            <topic>
                <title>InvokeEvent(event, count)</title>
            </topic>
            <topic>
                <title>InvokeBaseCtor(method, count)</title>
            </topic>
            <topic>
                <title>AttachEvent(event)</title>
            </topic>
            <topic>
                <title>DetachEvent(event)</title>
            </topic>
        </topic>
        <topic>
            <title>Testing Operations</title>
            <topic>
                <title>TestElementInSet</title>
            </topic>
            <topic>
                <title>CompareLiteral(type)</title>
            </topic>
            <topic>
                <title>CompareReference</title>
            </topic>
            <topic>
                <title>CompareValue</title>
            </topic>
            <topic>
                <title>OpLT, OpGT, OpLE, OpGE, OpEQ, OpNE</title>
            </topic>
        </topic>
        <topic>
            <title>Unary Operations</title>
            <topic>
                <title>OpNot(type)</title>
            </topic>
            <topic>
                <title>OpPositive(type)</title>
            </topic>
            <topic>
                <title>OpNegative(type)</title>
            </topic>
        </topic>
        <topic>
            <title>Binary Operations</title>
            <topic>
                <title>OpConcat</title>
            </topic>
            <topic>
                <title>OpExp(type)</title>
            </topic>
            <topic>
                <title>OpAdd(type)</title>
            </topic>
            <topic>
                <title>OpSub(type)</title>
            </topic>
            <topic>
                <title>OpMul(type)</title>
            </topic>
            <topic>
                <title>OpDiv(type)</title>
            </topic>
            <topic>
                <title>OpShl(type)</title>
            </topic>
            <topic>
                <title>OpShr(type)</title>
            </topic>
            <topic>
                <title>OpXor(type)</title>
            </topic>
            <topic>
                <title>OpAnd(type)</title>
            </topic>
            <topic>
                <title>OpOr(type)</title>
            </topic>
        </topic>
    </topic>
</article>