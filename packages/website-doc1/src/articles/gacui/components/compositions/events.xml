<article index="true">
    <topic>
        <title>Handling Input Events</title>
        <p>
            Raw input events are in compositions.
            Normally a composition doesn't receive events,
            until <b>GuiGraphicsComposition</b>::<b>GetEventReceiver</b> is called.
            This function create a big object containing all event registrations inside it,
            and cause <b>GuiGraphicsComposition</b>::<b>HasEventReceiver</b> to become <b>true</b> forever.
            You are not able to free the space of event registration object once it is associated to a composition.
        </p>
        <p>
            In the event registration object you will find a lot of fields for events,
            for example,
            <b>leftButtonDown</b>.
            There are 3 methods for subscribing an event:
            <ul>
                <li>
                    composition-&gt;GetEventReceiver()-&gt;EVENT_NAME.<b>AttachMethod</b>:
                    subscribe an event using an object and a member function pointer.
                </li>
                <li>
                    composition-&gt;GetEventReceiver()-&gt;EVENT_NAME.<b>AttachFunction</b>:
                    subscribe an event using a function pointer or a <b>vl::Func&lt;...&gt;</b> functor.
                </li>
                <li>
                    composition-&gt;GetEventReceiver()-&gt;EVENT_NAME.<b>AttachLambda</b>:
                    subscribe an event using a lambda expression or other functors.
                </li>
            </ul>
            All 3 methods returns a new handler object per each call.
            The only purpose for this object is to use in
            composition-&gt;GetEventReceiver()-&gt;EVENT_NAME.<b>Detach</b>
            and cancel the registration that returning that perticular handler object.
            If <b>Detach</b> returns <b>false</b>,
            either this registration has already been canceled,
            or this registration doesn't happen in this event.
        </p>
        <p>
            In the event callback function,
            the first argument is always <b>GuiGraphicsComposition*</b>,
            the second argument varies in different events.
        </p>
        <p>
            In GacUI XML Resource,
            raw input events are treated like attributes of a composition.
            You can either specify a method name of the current instance,
            or specify a piece of code to run.
            Please check out <a href="/gacui/xmlres/instance/events.html">this page</a> for details.
        </p>
        <topic>
            <title>Mouse Events</title>
            <topic>
                <title>Button and Wheel Events</title>
                <p>
                    GacUI offers the following button events:
                    <ul>
                        <li>leftButtonDown</li>
                        <li>leftButtonUp</li>
                        <li>leftButtonDoubleClick</li>
                        <li>middleButtonDown</li>
                        <li>middleButtonUp</li>
                        <li>middleButtonDoubleClick</li>
                        <li>rightButtonDown</li>
                        <li>rightButtonUp</li>
                        <li>rightButtonDoubleClick</li>
                        <li>horizontalWheel</li>
                        <li>verticalWheel</li>
                    </ul>
                    mapping to the 5 standard buttons of a mouse.
                    But a typical mouse today,
                    middle button and vertical wheel are merged together,
                    horizontal wheel are usually missing.
                </p>
                <p>
                    The type of the second argument is <b>vl::presentation::compositions::GuiMouseEventArgs&amp;</b>,
                    or <b>presentation::composition::GuiMouseEventArgs*</b> in <b>Workflow</b>.
                </p>
                <p>
                    When such event happens,
                    the composition right under the mouse will receive the event,
                    and then its parent composition,
                    and its parent parent composition until the end.
                    Such process could be detected using members of the second argument:
                    <ul>
                        <li>
                            <b>compositionSource</b>:
                            the composition right under the mouse, which is the original event raiser.
                            When the event raises through the parent chain,
                            this member doesn't change.
                        </li>
                        <li>
                            <b>eventSource</b>:
                            the owner of the current raising event.
                            When the event raises through the parent chain,
                            this member reflect the current one in the chain.
                            This is the same to the first argument of the event callback function.
                        </li>
                        <li>
                            <b>handled</b>:
                            you can set this member in the event callback function to <b>true</b>
                            to stop the event from going through more further in the parent chain.
                        </li>
                    </ul>
                </p>
                <p>
                    Other members contains the information of the event:
                    <ul>
                        <li><b>ctrl</b>: <b>true</b> if the CTRL key is pressing.</li>
                        <li><b>shift</b>: <b>true</b> if the SHIFT key is pressing.</li>
                        <li><b>left</b>: <b>true</b> if the mouse left button is pressing.</li>
                        <li><b>middle</b>: <b>true</b> if the mouse middle button is pressing.</li>
                        <li><b>right</b>: <b>true</b> if the mouse right button is pressing.</li>
                        <li><b>x</b> and <b>y</b>: the relative coordinate to <b>eventSource</b>.</li>
                        <li>
                            <b>wheel</b>:
                            direction and distance of the wheel. A positive number means the wheel is rotating towards right or down.
                            The unit of the rotation is 120 for today's typical mouse.
                        </li>
                    </ul>
                </p>
            </topic>
            <topic>
                <title>Moving Events</title>
                <p>
                    GacUI offers the following button events:
                    <ul>
                        <li>mouseMove</li>
                        <li>mouseEnter</li>
                        <li>mouseLeave</li>
                    </ul>
                    mapping to the 5 standard buttons of a mouse.
                    But a typical mouse today,
                    middle button and vertical wheel are merged together,
                    horizontal wheel are usually missing.
                </p>
                <p>
                    <b>mouseEnter</b> happens when the mouse moves into a composition.
                    <b>mouseLeave</b> happens when the mouse moves out of a composition.
                    When a mouse moves from one composition to its child composition,
                    it doesn't count as leaving the original composition,
                    it is still in the original composition and its child composition.
                </p>
                <p>
                    <b>mouseMove</b> happens when the mouse moves.
                    It behaves like other button and wheel events
                    in the way of raise through the parent chain.
                </p>
            </topic>
            <topic>
                <title>Capturing</title>
                <p>
                    When a button down event happens,
                    the <b>compositionSource</b> is captured.
                    A captured composition becomes the <b>compositionSource</b>
                    of all following mouse events happen in the containing window (or menu, popup, etc...),
                    including button up events.
                </p>
                <p>
                    After the button up event happens,
                    the capturing is released.
                </p>
            </topic>
            <topic>
                <title>Moving or deleting controls or compositions during mouse events.</title>
                <p>
                    Some times you may want to change the control tree structure in a callback of mouse events,
                    (including <b>Clicked</b> in buttons).
                </p>
                <p>
                    This is tricky because,
                    mouse events are not just sent to this composition,
                    it is sent to all its parent compositions.
                    Even when <b>handled</b> is set to <b>true</b>,
                    there is still something to do after the callback function ends.
                </p>
                <p>
                    When you move or delete controls or compositions that affect the parent chain,
                    <b>GacUI will stably CRASH</b>.
                </p>
                <p>
                    In order to solve this issue,
                    <b>GetApplication()-&gt;InvokeInMainThread</b> is your friend.
                    Whenever you call this function,
                    the callback to <b>InvokeInMainThread</b> will run
                    right after the current series of events.
                    That is a very safe point to restructure your controls or compositions.
                </p>
                <p>
                    For example,
                    if you customize the tab control to have a close button in each tab page:
                    <program>
                        <code><![CDATA[
                            void MyTabPage::buttonCloseClicked(GuiGraphicsComposition* sender, GuiEventArgs& arguments)
                            {
                                // this is still in the chain of mouse button events,
                                // so InvokeInMainThread is required to delete MyTabPage.
                                GetApplication()->InvokeInMainThread(this->GetRelatedControlHost(), [=]()
                                {
                                    this->GetOwnerTab()->GetPages().Remove(this);
                                    SafeDeleteControl(this);
                                });
                            }
                        ]]></code>
                    </program>
                </p>
            </topic>
        </topic>
        <topic>
            <title>Keyboard Events</title>
            <p>
                GacUI offers the following button events:
                <ul>
                    <li>previewKey</li>
                    <li>keyDown</li>
                    <li>keyUp</li>
                    <li>systemKeyDown</li>
                    <li>systemKeyUp</li>
                </ul>
            </p>
            <p>
                The type of the second argument is <b>vl::presentation::compositions::GuiKeyEventArgs&amp;</b>,
                or <b>presentation::composition::GuiKeyEventArgs*</b> in <b>Workflow</b>.
            </p>
            <p>
                Other members contains the information of the event:
                <ul>
                    <li><b>ctrl</b>: <b>true</b> if the CTRL key is pressing.</li>
                    <li><b>shift</b>: <b>true</b> if the SHIFT key is pressing.</li>
                    <li><b>alt</b>: <b>true</b> if the ALT button is pressing.</li>
                    <li><b>capslock</b>: <b>true</b> if the CAPSLOCK button is activated.</li>
                    <li><b>autoRepeatKeyDown</b>: <b>true</b> if this event is generated because of holding a key.</li>
                </ul>
            </p>
        </topic>
        <topic>
            <title>Input Events</title>
            <p>
                GacUI offers the following button events:
                <ul>
                    <li>previewCharInput</li>
                    <li>charInput</li>
                    <li>gotFocus</li>
                    <li>lostFocus</li>
                    <li>caretNotify</li>
                </ul>
            </p>
            <p>
                The type of the second argument is <b>vl::presentation::compositions::GuiCharEventArgs&amp;</b>,
                or <b>presentation::composition::GuiCharEventArgs*</b> in <b>Workflow</b>.
            </p>
            <p>
                
            </p>
            <p>
                Other members contains the information of the event:
                <ul>
                    <li><b>ctrl</b>: <b>true</b> if the CTRL key is pressing.</li>
                    <li><b>shift</b>: <b>true</b> if the SHIFT key is pressing.</li>
                    <li><b>alt</b>: <b>true</b> if the ALT button is pressing.</li>
                    <li><b>capslock</b>: <b>true</b> if the CAPSLOCK button is activated.</li>
                </ul>
            </p>
        </topic>
        <topic>
            <title>Focus Events</title>
            <p>
                GacUI offers the following button events:
                <ul>
                    <li>gotFocus</li>
                    <li>lostFocus</li>
                    <li>caretNotify</li>
                </ul>
            </p>
            <p>
                The type of the second argument is <b>vl::presentation::compositions::GuiEventArgs&amp;</b>,
                or <b>presentation::composition::GuiEventArgs*</b> in <b>Workflow</b>.
            </p>
        </topic>
        <topic>
            <title>Other Events</title>
            <p>
                GacUI offers the following button events:
                <ul>
                    <li>clipboardNotify</li>
                    <li>renderTargetChanged</li>
                </ul>
            </p>
            <p>
                The type of the second argument is <b>vl::presentation::compositions::GuiEventArgs&amp;</b>,
                or <b>presentation::composition::GuiEventArgs*</b> in <b>Workflow</b>.
            </p>
            <p>
                When content in the system clipboard changes,
                <b>clipboardNotify</b> raises in every compositions.
            </p>
            <p>
                When the render target is changed,
                this may because a composition is added to or remove from a window,
                or the window itself loses and recreates its render target,
                <b>renderTargetChanged</b> raises in the affected root composition and all direct or indirect child compositions.
            </p>
            <p>
                If a composition is not added to a window,
                its render target is <b>null</b>.
            </p>
        </topic>
    </topic>
</article>